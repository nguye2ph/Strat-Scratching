--- City of Los Angeles
--sql server
SELECT
    *
FROM
    los_angeles_restaurant_health_inspections
WHERE 
    program_status = 'INACTIVE'

#pandas 

import pandas as pd
los_angeles_restaurant_health_inspections[los_angeles_restaurant_health_inspections['program_status'] == 'INACTIVE']

-- salary difference 

select 
ABS(MAX(CASE WHEN d.department = 'engineering'
THEN e.salary ELSE 0 END) - MAX(CASE WHEN d.department = 'marketing'
THEN e.salary ELSE 0 END))
AS salary_difference
from db_employee e
JOIN db_dept d
ON e.department_id = d.id
;

# Pandas 
import pandas as pd

db_employee.head()
db_employee_dept = db_employee.merge(db_dept, how = 'left', left_on = 'department_id', right_on = 'id')
db_employee_dept.head()
highest_marketing = db_employee_dept.loc[db_employee_dept['department'] == 'marketing','salary'].max()
highest_engineering = db_employee_dept.loc[db_employee_dept['department'] == 'engineering','salary'].max()
highest_marketing - highest_engineering

-- current salary 
select 
id, 
first_name, 
last_name,
department_id, 
salary
FROM 
(
SELECT *
, ROW_NUMBER() OVER (PARTITION BY id, first_name, last_name ORDER BY salary DESC, department_id DESC) AS row_num
from ms_employee_salary
) AS X
WHERE X.row_num = 1
ORDER BY X.id ASC

## pandas
import pandas as pd

ms_employee_salary.groupby(['id','first_name','last_name','department_id'])['salary'].max().reset_index()

-- April and May Sign Up sql server

SELECT DISTINCT signup_id
FROM transactions
WHERE DATEPART(month, transaction_start_date) IN (4,5);

## Pandas

import pandas as pd
import datetime as dt

transactions["transaction_start_date"] = pd.to_datetime(
    transactions["transaction_start_date"]
)
transactions["month"] = transactions["transaction_start_date"].dt.month

select_months = transactions[(transactions["month"].isin([4, 5]))]
result = select_months["signup_id"].unique()


## airbnb sanfrancisco

select *
from airbnb_search_details
WHERE cancellation_policy = 'flexible'
AND review_scores_rating IS NOT NULL
AND city = 'SF'
ORDER BY review_scores_rating DESC;

import pandas as pd
import numpy as np

SF_searches = airbnb_search_details[(airbnb_search_details['city'] == 'SF') & (airbnb_search_details['cancellation_policy'] == 'flexible')
                                    & (airbnb_search_details['review_scores_rating'].notnull()) ]
result = SF_searches.sort_values(['review_scores_rating'],ascending = False)

-- Speed Express
select COUNT(order_id) from shopify_orders so 
INNER JOIN shopify_carriers sc
ON so.carrier_id = sc.ID
WHERE sc.name = 'Speedy Express'

##pandas
orders_and_carriers = shopify_orders.merge(shopify_carriers, left_on='carrier_id', right_on='id')
result = orders_and_carriers[orders_and_carriers['name'].str.lower() == 'speedy express'].shape[0]

-- unique worker ids

select DISTINCT worker_id from worker_logins
WHERE login_timestamp BETWEEN '12/13/2021' AND '12/19/2021';

##pandas 

import pandas as pd
import datetime as dt

worker_logins["login_timestamp"] = pd.to_datetime(worker_logins["login_timestamp"])
dates_df = worker_logins[
    worker_logins["login_timestamp"].between("2021-12-13", "2021-12-19")
]
result = dates_df["worker_id"].unique()

--airbnb

select * from airbnb_search_details
WHERE property_type = 'Apartment'
AND accommodates = 1

##pandas

import pandas as pd
import numpy as np

result = airbnb_search_details[(airbnb_search_details['accommodates'] == 1) & (airbnb_search_details['property_type'] == 'Apartment')]


-- air bnb 2
select * from airbnb_search_details
WHERE host_response_rate IS NULL;

##pandas 
import pandas as pd
import numpy as np

result = airbnb_search_details[airbnb_search_details['host_response_rate'].isnull()]


-- pending claims

select 
COUNT(claim_id) AS n_claims
from cvs_claims
WHERE DATEPART(year, date_submitted) = 2021
AND DATEPART(month, date_submitted) = 12
AND date_accepted IS NULL
AND date_rejected IS NULL
;

## pandas 

# Import your libraries
import pandas as pd

# Start writing code
cvs_claims.head()
start_date = '2021-12-01'
end_date = '2021-12-31'
cvs_claims[(cvs_claims['date_accepted'].isna()) & (cvs_claims['date_rejected'].isna())& (cvs_claims['date_submitted']>= start_date) & (cvs_claims['date_submitted'] <= end_date)].shape[0]

-- product with no sales

select dim.prod_sku_id, dim.market_name
from fct_customer_sales fct
RIGHT JOIN dim_product dim
ON fct.prod_sku_id = dim.prod_sku_id 
WHERE fct.order_value IS NULL

##pandas 
sales_and_products = fct_customer_sales.merge(dim_product, on='prod_sku_id', how='right')
result = sales_and_products[sales_and_products['order_id'].isna()][['prod_sku_id', 'market_name']]

----Aroma Based Winery Search
--METHOD 1
/*
SELECT DISTINCT winery
FROM winemag_p1
WHERE description LIKE '%plum[,. /-]%'
OR description LIKE '%cherry[,. /-]%' 
OR description LIKE '%rose[,. /-]%' 
OR description LIKE '%hazelnut[,. /-]%' 
ORDER BY 1
*/

--METHOD 2
SELECT DISTINCT winery
FROM winemag_p1
WHERE description LIKE '%[^a-z]plum[^a-z]%'
OR description LIKE '%[^a-z]cherry[^a-z]%' 
OR description LIKE '%[^a-z]rose[^a-z]%' 
OR description LIKE '%[^a-z]hazelnut[^a-z]%' 
ORDER BY 1

SELECT DISTINCT winery
FROM winemag_p1
WHERE ' ' + lower(description) + ' ' LIKE '% plum %'
  OR ' ' + lower(description) + ' ' LIKE '% cherry %'
  OR ' ' + lower(description) + ' ' LIKE '% rose %'
  OR ' ' + lower(description) + ' ' LIKE '% hazelnut %'
EXCEPT
SELECT DISTINCT winery
FROM winemag_p1
WHERE ' ' + lower(description) + ' ' LIKE '% plums %'
  OR ' ' + lower(description) + ' ' LIKE '% cherries %'
  OR ' ' + lower(description) + ' ' LIKE '% roses %'
  OR ' ' + lower(description) + ' ' LIKE '% hazelnuts %'

## pandas

import pandas as pd

include = winemag_p1['description'].str.lower().str.contains(
r'\b(plum|cherry|rose|hazelnut)\b', regex=True)

exclude = winemag_p1['description'].str.lower().str.contains(
r'\b(plums|cherries|roses|hazelnuts)\b', regex=True)

result = winemag_p1[include & ~exclude][['winery']].drop_duplicates()


-----------------------------
select SUM(order_total ) AS revenue from amazon_sales
WHERE year(order_date) =2021


# Import your libraries
import pandas as pd

result = amazon_sales[amazon_sales['order_date'].dt.year == 2021['order_total'].sum()
df = pd.DataFrame({'REVENUE': [result]})

return
---------------------------------------------------
--- number of hires between specific time period

select COUNT(*) from employees
WHERE joining_date BETWEEN '01/01/2022'
AND '07/31/2022'
;

SELECT COUNT(*)
FROM employees
WHERE joining_date BETWEEN CAST('2022-01-01' AS DATE) AND CAST('2022-08-01' AS DATE);

select count(*) 
from employees
where year(joining_date) = 2022 and month(joining_date) between 01 and 07 ;

# Import your libraries
import pandas as pd

# Start writing code
employees.head()

employees[(employees['joining_date'] >= '2022-01-01') & (employees['joining_date'] < '2022-08-01')]['id'].count()

--- Non HS SAT Score
select * from sat_scores
WHERE school NOT LIKE '%HS'

SELECT
    *
FROM sat_scores
WHERE 
    RIGHT(school, 2) <> 'HS'

select * 
from sat_scores
where right(trim(school), 2) <> 'hs'

select * from sat_scores
where CHARINDEX('HS', school)=0

------
SELECT
    count(distinct movie) AS n_movies_by_abi
FROM oscar_nominees
WHERE 
    nominee = 'Abigail Breslin'
--count distinct not distinct count
--COUNT(column) executes first - it aggregates and counts all rows
--DISTINCT is applied second - it tries to remove duplicates from the result set

--doesn't work with window function though might need to use subquery and row_number(). works with groupby

WITH distinct_movies AS (
    SELECT DISTINCT 
        nominee, 
        movie
    FROM oscar_nominees
)
SELECT 
    nominee,
    COUNT(*) OVER (PARTITION BY nominee) AS n_distinct_movies
FROM distinct_movies

import pandas as pd
import numpy as np

nominee = oscar_nominees[oscar_nominees['nominee'] == 'Abigail Breslin']
result = nominee.movie.nunique()

---- Numbers of Comments per user in 30 days

select
user_id,
SUM(number_of_comments) AS number_of_comments
from fb_comments_count
WHERE created_at BETWEEN DATEADD(day, -30, '2020-02-10') AND '2020-02-10'
GROUP BY user_id

;

SELECT
    user_id,
    SUM(number_of_comments) AS tot
FROM fb_comments_count
WHERE DATEDIFF(day, created_at, '2020-02-10') BETWEEN 0 AND 30
GROUP BY user_id

# Import your libraries
import pandas as pd
from datetime import timedelta

result = fb_comments_count[(fb_comments_count['created_at'] >= pd.to_datetime('2020-02-10') - timedelta(days=30)) & (
        fb_comments_count['created_at'] <= pd.to_datetime('2020-02-10'))].groupby('user_id')[
'number_of_comments'].sum().reset_index()


